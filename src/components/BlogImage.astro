---
import type { ImageMetadata } from 'astro';
import { getImage } from 'astro:assets';

interface Props {
	src: ImageMetadata;
	alt: string;
	lazy?: boolean;
	widths?: number[];
}

const { alt, src, widths } = Astro.props;

const is_gif = src.format === 'gif';

// AVIFs screw up gifs
const avif = is_gif
	? null
	: await getImage({
			src,
			format: 'avif',
			widths: widths ?? [1800, 1200, 600],
		});

const webp = await getImage({
	src,
	format: 'webp',
	widths: widths ?? [1800, 1200, 600],
});

const { loading: _, decoding: _1, ...attrs } = webp.attributes;
---

<div class="lazy-image-container">
	<!-- For some reason, putting lazy-load-image at top level just puts it out entirely and wraps it in a <p> tag -->
	<lazy-load-image>
		<figure
			class:list={{
				gif: is_gif,
			}}
			style={`--aspect: ${src.width}/${src.height};--width: ${webp.attributes.width}px;--height: ${webp.attributes.height}px`}
		>
			<picture>
				{avif && <source type="image/avif" data-srcset={avif.srcSet.attribute} />}

				<source type="image/webp" data-srcset={webp.srcSet.attribute} />
				<img class:list={{ gif: is_gif }} data-src={webp.src} alt={alt} {...attrs} />

				<div aria-hidden="true" class="overlay"></div>
			</picture>
		</figure>
	</lazy-load-image>
</div>

<script>
	const targets = new Set<LazyLoadImage>();

	let observer = new IntersectionObserver(
		(entries) => {
			entries.forEach((entry) => {
				if (!entry.isIntersecting) return;

				const target = entry.target as LazyLoadImage;
				console.log(target);

				const sources = Array.from(target.querySelectorAll('source'));

				if (!sources.length) return;

				const sources_remaining = sources.some((source) => source.hasAttribute('data-srcset'));
				if (!sources_remaining) {
					observer.unobserve(target);
					targets.delete(target);
					return;
				}

				for (const source of sources) {
					if (source.dataset.srcset) {
						source.setAttribute('srcset', source.dataset.srcset);
						source.removeAttribute('data-srcset');
					}
				}

				const img = target.querySelector('img');
				if (img) {
					console.log(img.getAttribute('data-src'));
					img.setAttribute('src', img.dataset.src!);
					img.removeAttribute('data-src');

					img.addEventListener('load', () => {
						img.classList.add('lazyloaded');
					});
				}
			});
		},
		{
			// We want to preload, so we'll load the image before it comes into viewport
			rootMargin: '400px',
			threshold: 0.01,
		},
	);

	class LazyLoadImage extends HTMLElement {
		connectedCallback() {
			observer.observe(this);
		}

		disconnectedCallback() {
			observer.unobserve(this);
		}
	}

	customElements.define('lazy-load-image', LazyLoadImage);
</script>

<style>
	.lazy-image-container {
		display: flex;
		justify-content: center;

		width: 100%;
	}
	figure {
		position: relative;

		display: flex;
		justify-content: center;

		margin: 0;
		padding: 0;
		aspect-ratio: var(--aspect);

		border-radius: 0.5rem;

		width: 100%;
		height: max-content;

		max-width: 100%;
		min-width: 0;

		&.gif {
			width: var(--width);
		}
	}

	picture {
		border-radius: inherit;
		display: contents;

		.overlay {
			display: block;
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: var(--app-color-primary);
			border-radius: inherit;
			opacity: 1;
			transition: opacity 200ms ease-in;

			z-index: 200;
		}

		&.no_overlay .overlay {
			opacity: 0;
		}
	}

	img {
		display: block;
		width: 100%;
		height: 100%;

		position: relative;

		aspect-ratio: var(--aspect);

		height: auto;
		opacity: 1;
		border-radius: inherit;

		&.lazyloaded + .overlay {
			opacity: 0;
		}

		&.gif {
			width: auto;
			max-width: 100%;
			min-width: 20rem;
		}
	}

	@media screen and (max-width: 600px) {
		.gif {
			max-width: 100% !important;
			width: 100% !important;
		}
	}
</style>
